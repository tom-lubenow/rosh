Got it. I’ll dig into the Mosh source code and documentation to outline the exact bootstrapping process over SSH. This will include how the client launches SSH, what data is transmitted during the SSH session, the roles of both the client and server during this phase, and how the client resolves the server's IP. The goal will be to describe the entire procedure in a platform-agnostic way that could be reimplemented in any language or system.

I'll let you know as soon as I have the full breakdown ready.


## Launching the SSH Connection and Starting *mosh-server*

When you run `mosh [user@]host`, the Mosh client first uses SSH to log into the remote machine under the hood. In fact, the `mosh` wrapper script (written in Perl) invokes the local SSH client to connect to `user@host` using your normal SSH authentication (public keys, password, etc.). By default it requests a pseudo-terminal (`ssh -tt`) so that the remote environment is a login shell context. Once authenticated, the Mosh client instructs SSH to execute the **mosh-server** program on the remote host. For example, the SSH command might look roughly like: `ssh user@host -- mosh-server new` (with appropriate options) – this launches `mosh-server` on the remote side as your user. The SSH step does not create any long-lived tunnel; it’s only used for setup and key exchange. After this point, no privileged ports or daemons are used – both the client and server are ordinary user processes lasting only for the session. (Note: If either the client or server binaries aren’t in the default `$PATH`, the `mosh` script adds `--client` or `--server` options to specify their location.)

**Server startup via SSH:** The SSH channel carries a command to run `mosh-server` on the host. Typically the client uses the `mosh-server new` invocation, which allows specifying options. The Mosh script may pass along environment variables (like locale settings) on the `mosh-server` command line (using `-l` flags or similar) to ensure the server has a UTF-8 locale. By default Mosh also allocates a pseudo-terminal for the SSH session (`--ssh-pty` is enabled by default). This ensures that any login profile scripts on the server run as they would in an interactive SSH session. (Allocating a TTY also helps avoid certain issues with output buffering or locale inheritance on some systems.) The SSH step might prompt for your SSH password or passphrase if needed, just like a normal SSH login – all of that is handled by the SSH client. Once the remote shell is established, the `mosh-server` program begins executing on the server side.

## *mosh-server* on the Remote Side (SSH Phase)

On the server, `mosh-server` initializes the Mosh session. It generates a fresh AES-128 secret key for the session and binds a UDP socket to an available high port number. By default, Mosh will choose a UDP port between 60000 and 61000 for the session. (This range is configurable – the user can specify a specific port or narrower range with the `-p PORT[:PORT2]` option, and `-p 0` lets the OS pick any free port. Note that this port is unrelated to SSH’s port 22; SSH is only used for setup.) The *mosh-server* then prints a one-line announcement to **stdout** with the chosen UDP port and the session key, in a specific format. For example: **`MOSH CONNECT 60004 4NeCCgvZFe2RnPgrcU1PQw`**. Here “60004” is the UDP port number and the second token is a 22-byte base64-like string that encodes the 128-bit AES key for this session.

Immediately after outputting this **“MOSH CONNECT \<port> \<key>”** line, the `mosh-server` process detaches from the SSH session (forking into the background). It **continues running on the server** in the background, waiting for the client to contact it over UDP. It also launches the user’s login shell (or specified command) on the server side, connected to a pseudo-terminal that *mosh-server* manages. At this point the SSH job is essentially done – the `mosh-server` is running and listening. If something goes wrong (for example, `mosh-server` isn’t installed on the server or fails to run), the client will not see a proper “MOSH CONNECT” line, and the `mosh` script will print an error like “Did not find mosh server startup message” before aborting.

**Details of server startup:** By default, `mosh-server` picks a random UDP port in the 60000–61000 range and listens on **all network interfaces** for that port. On platforms with multiple network interfaces or both IPv4/IPv6, Mosh can be told to bind specifically to the interface/IP used by the SSH connection: the `-s` option makes `mosh-server` bind only to the server’s IP address that the SSH session came in on (as provided in the `$SSH_CONNECTION` env variable). This is useful on multi-homed servers – it ensures the UDP socket is on the same network that the client used for SSH. Otherwise, by default `mosh-server` binds on all addresses (0.0.0.0 or ::) for the chosen port. The server also chooses a random 128-bit key (printed as the 22-character string) which will be used to symmetrically encrypt and authenticate all packets. After printing the **connect message**, `mosh-server` daemonizes and **waits for the client**. If no client contacts it within 60 seconds, it will time out and exit to avoid leaving stray processes. If the client connects in time, the server keeps running until the session ends, and will clean up when the user’s shell exits. (On systems with utmp/wtmp support, the server may also create a utmp login entry and update it with the client’s IP and connection status.) At this stage, the server is essentially idle, listening on the UDP port and capturing the output of the user’s shell (but it won’t send anything yet, since no client is attached).

## Exchanging Port and Key over SSH

The only data exchange that occurs over the SSH channel (aside from normal SSH authentication) is the transmission of the session coordinates: the UDP port number and the secret key. The **mosh-server** prints this information to its standard output, which is forwarded over the SSH tunnel back to the client. The local `mosh` script reads this output from SSH. In other words, the client is “waiting” for a line beginning with `MOSH CONNECT` from the remote side. Once the Mosh client sees the “MOSH CONNECT …” line, it knows the server’s UDP listening port and the session key. At this point, the SSH connection has served its purpose. The `mosh` client instructs SSH to cleanly close (the SSH channel terminates as the remote command has finished), and the terminal drops out of the SSH session. From here onward, Mosh will communicate directly over UDP.

**What exactly is sent:** The Mosh client does not send any custom data *to* the server over SSH beyond launching `mosh-server`. The key exchange is one-way: *mosh-server* sends the port and key to the client (by printing them). That key is a random AES-128 key that both sides will use for encryption (no further Diffie–Hellman or handshake needed, since it’s randomly generated on the server and shared via the secure SSH channel). The client, upon receiving this, stores the key and port. Internally, the `mosh` wrapper populates an environment variable (e.g. `MOSH_KEY`) with the base64 session key and then launches the real `mosh-client` binary as a child process with that environment variable set. (The Mosh developers specifically caution that the OS should protect process environments from other users, since the AES key lives in the env of the running client.) In summary, the SSH bootstrap carries *only*: the command to start the server, and the server’s reply containing *“<UDP-port> <session-key>”*. This information is conveyed in plain text over the already-secure SSH channel. Once this exchange is done, both sides have all they need to transition to the UDP protocol.

## Resolving the Server’s IP Address (IPv4/IPv6)

After the SSH phase, the client must determine *which network address to use* to reach the server’s UDP port. In many cases, this is straightforward (the host name you provided resolves to a single IP, or you directly specified an IP). However, if the hostname has both IPv4 and IPv6 addresses (a dual-stack host), or multiple A/AAAA records, the Mosh client has to pick one. By default, Mosh **prefers IPv4** for dual-stack hosts, but it can be configured with `--family` options to prefer IPv6 or to handle other situations. Specifically, the default is `--family=prefer-inet`, meaning Mosh will choose from all available addresses but try IPv4 first. Mosh’s IPv6 support was historically limited but as of recent versions it fully supports IPv6 on most platforms (it will select a single v4 or v6 address at session start, since the protocol itself doesn’t send data over multiple addresses).

**Address selection algorithm:** The `mosh` client performs a DNS lookup (or uses getaddrinfo) on the hostname to get all candidate IP addresses. If a specific `--family` is set (e.g. `inet6` for IPv6 only or `inet` for IPv4 only), it will restrict to those. With the default (`prefer-inet`), it will take all addresses but attempt the IPv4 list first before IPv6. (There is also a mode `--family=all` that will accept whichever address responds, requiring both sides to handle dual-stack roaming, but that is an advanced usage.) In practice, after SSH exits, the `mosh` script launches `mosh-client` with a *particular server IP and the UDP port* obtained earlier. For example: `mosh-client 198.51.100.10 60004` (and with the `MOSH_KEY` env set). Typically, the IP chosen is the same one that the SSH connection just used – on most systems, the DNS resolution and routing for SSH will have already picked a working address. (Mosh doesn’t explicitly query the SSH process for which address was used, but since it resolves the host similarly, it usually matches. If needed, users can force a family or specify a particular IP in the mosh command to avoid ambiguity.) If the first address fails to connect (no UDP response), Mosh may try the next address from DNS. However, in default mode Mosh will actually stop and ask you to pick `--family=inet` or `--family=inet6` explicitly if it detects multiple addresses (to avoid guessing wrong). In newer versions with `--family=all`/`prefer-inet`, the client *will* try addresses in sequence – for example, try IPv4, and if the UDP handshake fails, fall back to IPv6. The end result is that the client obtains a single remote IP address that it will target for the rest of the session. (That address can be IPv4 or IPv6; Mosh supports both, and roaming between networks of the same family. Roaming between v4 and v6 on the fly is possible only if the server has both and the client switches – Mosh 1.2.5+ added support for updating the server of a family change in client’s IP during roaming.)

*Note:* If the server is multi-homed (multiple network interfaces/IPs), the `-s` option mentioned earlier ensures the server bound the UDP socket to the specific interface that corresponded to the SSH connection. This means the client must use that same IP to reach the server. In such cases, the **“MOSH CONNECT”** message doesn’t explicitly include the IP, but the client implicitly knows which one it used for SSH or gets it via DNS resolution order. (For debugging, if needed, one can manually look up the host’s IP that was used – the Mosh FAQ suggests using the `host` command to resolve names if uncertain.) In summary, the client picks the server’s IP address through DNS lookup and its family selection policy, aligning with the address that was reachable during the SSH login.

## Determining the UDP Port to Contact

The UDP port number that the Mosh client will contact is exactly the port reported by the server during setup. As described, the server chooses a port (random by default, or specified by user options) and sends it to the client over SSH. The client does not independently choose the port; it trusts the server’s choice. Thus, once the SSH phase is done, the client knows “Server IP = X.X.X.X (or some IPv6), UDP port = NNNNN”. The local `mosh-client` process is then started with those parameters. The client will also bind a local UDP port on its end (usually an ephemeral port chosen by the OS; unlike the server, the client doesn’t restrict itself to 60000–61000 range, since it’s the one initiating the connection).

If the user specified a `-p` option when invoking Mosh, this instructs the server to use that port (or range). For instance, `mosh -p 60001 user@host` will cause the server to bind UDP 60001 (if available) and the client will then use 60001. You can also give a range (`-p 60000:60010`) to restrict to those ports, which is useful for firewall configurations. But importantly, the client doesn’t need to “figure out” the port — the server **tells it**. The port is embedded in the “MOSH CONNECT” message and parsed out by the client script. Only after obtaining this does the client proceed. (In a manual scenario, if you were debugging, you could run `mosh-server` manually on the server and see it print e.g. `MOSH CONNECT 60004 ...`, then on the client run `mosh-client serverIP 60004` with the given key.) In short, the UDP port selection is entirely handled by the server and communicated directly to the client over SSH, which then uses that port number for the UDP session.

## Switching to UDP and the Mosh Handshake

Once the client has launched `mosh-client` with the server’s IP and port, both sides begin the **State Synchronization Protocol (SSP)** over UDP. At this point the SSH connection is closed, and Mosh’s custom UDP-based protocol takes over. The first step in this UDP phase is for the client to initiate contact. The Mosh client sends a UDP datagram to the server’s IP and UDP port. This packet is encrypted and authenticated with the AES-128 key that was shared (Mosh uses AES in OCB mode for encryption+MAC). Because both sides already share the secret key, there’s no additional key negotiation needed – the very first packet can be encrypted. The server, which is listening on that UDP port, will receive the packet and attempt to decrypt it. If the packet decrypts and the MAC is valid (i.e. the correct key was used), the server knows this is the legitimate client. This essentially **authenticates the client** to the server (and likewise, the client will only accept properly keyed responses from the server). Thus, the secrecy and integrity of the session are bootstrapped by the key from SSH.

**UDP handshake process:** The “handshake” here is lightweight. Unlike TCP, there isn’t a multi-step SYN/SYN-ACK handshake. Instead, the client’s first valid encrypted packet serves as an introduction. The server responds with its own first packet as soon as it has something to send (likely immediately an acknowledgment or the initial screen update). In practice, Mosh’s protocol is built around exchanging the current state of the terminal and user input rather than raw bytes. So, after the initial contact, the server will send a snapshot of the current terminal screen state to the client, and the client can send any initial input state (usually just a “heartbeat” or empty message initially). This exchange establishes both directions of the session. Internally, Mosh runs two instances of SSP – one from client to server (carrying user keystrokes and terminal resize events) and one from server to client (carrying the screen updates). Each instance has its own sequence numbers. During the handshake, the client and server also exchange their **version info and capabilities** to ensure compatibility (for example, they verify that both speak the same protocol version). This might be done implicitly by protocol messages – Mosh has a defined protocol version, and mismatches would lead to a disconnect, though in practice most Mosh versions are interoperable.

The very first datagrams also serve to establish **roaming state**. The server notes the UDP source address and port of the client’s packet. Mosh is designed such that if the client’s IP changes during the session, the client will start sending from a new IP and the server will automatically update its target to that new address (as long as the packets carry the right key and an incremented sequence number). At start, this simply means the server records the client’s IP/port from the initial UDP packet and will send replies to that address. (If the client was behind NAT, this initial outgoing packet also punches a hole in the NAT so that the server’s reply can come through on the same mapping.)

**Handshake completion:** After a few initial packets, the Mosh client and server have confirmed the key and established the synchronizing streams. The client’s terminal will typically clear and redraw with the server’s screen output (for example, you’ll see your shell prompt appear – this might be accompanied by any MOTD or last-login message that a normal SSH login would show, which *mosh-server* captured from the shell startup). At this point, the “session” is fully live over UDP. The SSH process on the client has already exited, and the terminal is now attached to the `mosh-client` process. From the user’s perspective, it looks just like an SSH session, but underneath it’s now the Mosh protocol carrying updates.

All further communication is via UDP with the encrypted SSP protocol. Every keystroke you type is sent in a datagram to the server (encrypted with the shared key), and the server sends back diffs of the screen state to update your terminal. Mosh’s protocol is resilient: it does not require reliable delivery of every packet. Instead, it cares about the latest state. If packets are lost or out of order, that’s okay – the server will send new updates and the client will synchronize to the latest screen state, rather than needing every intermediate byte. This is why there isn’t a need for an ongoing ACK mechanism like TCP’s; however, Mosh does send periodic heartbeats (at least every 3 seconds by default) so that both sides know the connection is alive. If the client doesn’t hear from the server for a while, it will warn the user, but keep trying. If connectivity returns (even with a new IP), the session continues without needing to re-authenticate.

To summarize the handshake: **(1)** Client sends an initial encrypted UDP packet to server; **(2)** Server recognizes it (correct key) and replies with its own packet (which might contain initial screen data or an ack); **(3)** Both sides then consider the session established and continue exchanging UDP packets regularly. The shared key secures all traffic (AES-128-OCB encryption/authentication on each datagram). Sequence numbers in each packet ensure old or duplicated packets are ignored, and facilitate roaming (the server trusts the latest sequence from a given IP). There is no separate “UDP port negotiation” beyond the server’s initial choice, and no need for a third party – it’s a direct UDP conversation. At this point, the terminal session is live and interactive over UDP, implementing the high-level state sync that makes Mosh unique (speculative local echo, etc., are now in effect on the client side, but that is beyond the scope of the bootstrap process).

## Full Flow Recap

From the moment you run `mosh user@host` to the moment you get a live shell prompt, the sequence is: **1)** The Mosh client opens an SSH connection to `user@host` and authenticates in the normal way. **2)** Over that SSH session, it runs `mosh-server` on the remote side. **3)** The *mosh-server* allocates a UDP port (by default in the 60000-61000 range) and generates a session key, then outputs those to the client over SSH. **4)** The client receives the “MOSH CONNECT” message containing the UDP port and key, then terminates the SSH connection. **5)** The client resolves the server’s hostname to an IP address (honoring IPv4/IPv6 preferences) to know where to send UDP packets. **6)** The client launches `mosh-client` locally, providing it the server’s IP, the UDP port, and the AES key (the key via an env var). **7)** The `mosh-client` sends an encrypted datagram to the server’s UDP port to initiate contact. **8)** The *mosh-server*, which is listening, validates the packet (using the shared key) and then attaches the client to the session, sending back an encrypted response (e.g. initial screen state). **9)** The UDP handshake completes with this exchange – now the client and server speak Mosh’s SSP protocol over UDP, updating each other’s state. The user sees their remote shell prompt appear, and from here the session behaves like a robust, roaming SSH replacement, entirely over UDP. Both client and server will maintain the session until the user logs out or either side times out due to prolonged network silence. This entire process happens quickly (usually a fraction of a second, plus any SSH authentication time), and is what allows Mosh to set up its connection and then deliver a resilient remote terminal experience.

**Sources:**

* Mosh README and documentation on how Mosh uses SSH to launch the server and then switches to UDP.
* Mosh manual pages (Arch Linux) and FAQ describing `mosh-server` behavior, port selection, and usage of the “MOSH CONNECT” message.
* Excerpts from the official Mosh research paper (USENIX 2012) detailing the bootstrapping process and security (shared key, UDP port) and the design of the UDP-based State Synchronization Protocol.
* Mosh man page notes on IPv4/IPv6 support and address selection policies.
* Mosh website FAQ/examples showing manual startup and environment variable usage for keys.

